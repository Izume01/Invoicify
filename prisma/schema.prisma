generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserType {
  USER
  ADMIN
  SUPER_ADMIN
  GUEST
  OWNER
}

enum InvoiceStatus {
  DRAFT
  SENT
  PAID
  OVERDUE
}

enum InvoiceAccessType {
  VIEW
  EDIT
  DELETE
}

enum PaymentMethod {
  BANK
  PAYPAL
  CRYPTO
}

enum PaymentTerms {
  NET30
  NET45
  NET60
}

enum CurrencySupported {
  USD
  EUR
  GBP
  INR
}

model User {
  id               Int             @id @default(autoincrement())
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  clerkId          String          @unique
  name             String?
  email            String?
  imageUrl         String?
  userType         UserType        @default(USER)
  IsonBoardingDone Boolean         @default(false)
  Boarding         OnBoarding?     @relation(fields: [onBoardingId], references: [id])
  invoices         Invoice[]
  accesses         InvoiceAccess[]
  onBoardingId     Int?
}

model OnBoarding {
  id      Int    @id @default(autoincrement())
  option1 String
  option2 String
  option3 String
  option4 String
  User    User[]
}

model Client {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name    String
  email   String
  address String
  city    String
  state   String
  zip     String
  country String
  phone   String
  website String
  notes   String?

  invoices Invoice[]
}

model Invoice {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId Int
  user   User @relation(fields: [userId], references: [id])

  clientId Int
  client   Client @relation(fields: [clientId], references: [id])

  invoiceName   String
  invoiceNumber String            @unique
  currency      CurrencySupported

  FromName    String
  FromEmail   String
  FromAddress String

  ClientName    String
  ClientEmail   String
  ClientAddress String

  invoiceDate DateTime
  dueDate     DateTime
  status      InvoiceStatus @default(DRAFT)

  paymentMethod PaymentMethod?
  paymentTerms  PaymentTerms?
  notes         String?

  cryptoAddress String? // For crypto payments
  paypalEmail   String? // For PayPal payments

  bankAccountNumber String? // For bank transfer
  bankSwiftCode     String?
  bankName          String?

  items       InvoiceItem[]
  emailDrafts EmailDraft[]
  accesses    InvoiceAccess[]
}

model InvoiceItem {
  id        Int     @id @default(autoincrement())
  invoiceId Int
  invoice   Invoice @relation(fields: [invoiceId], references: [id])

  name        String
  description String
  quantity    Int
  unitPrice   Float
  total       Float
}

model EmailDraft {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  invoiceId Int
  invoice   Invoice @relation(fields: [invoiceId], references: [id])

  subject String
  body    String
}

model InvoiceAccess {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  invoiceId Int
  invoice   Invoice @relation(fields: [invoiceId], references: [id])

  userId Int
  user   User @relation(fields: [userId], references: [id])

  accessType InvoiceAccessType @default(VIEW)
  token      String            @unique
}
